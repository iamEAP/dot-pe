{"version":3,"sources":["webpack:///./src/pages/engineers/better-wdc-performance-with-promises.js"],"names":["LegacyWdcPromisesPage","location","data","siteTitle","site","siteMetadata","title","keywords","img","promises","childImageSharp","fluid","src","className","href","target","waterfallSync","waterfallAsync","props","query","render"],"mappings":"isHAeMA,G,oBAAwB,SAAC,EAAUC,GAAc,IAAtBC,EAAqB,EAArBA,KACzBC,EAAYD,EAAKE,KAAKC,aAAaC,MAEzC,OACE,kBAAC,IAAD,CAAQA,MAAOH,GACb,kBAAC,IAAD,CACEG,MAAM,uCACNC,SAAU,CAAC,UAAD,2DACVC,IAAG,GAAKN,EAAKO,SAASC,gBAAgBC,MAAMC,MAG9C,6BAASC,UAAU,uCACjB,4BAAQA,UAAU,uBAChB,wBAAIA,UAAU,sBAAd,yCAEF,yBAAKA,UAAU,qBACb,4BAAQA,UAAU,uCAChB,kBAAC,IAAD,CACEF,MAAOT,EAAKO,SAASC,gBAAgBC,MACrCE,UAAU,aAEZ,sDAA2B,uBAAGC,KAAK,kEAAkEC,OAAO,UAAjF,oBAE7B,oSAOA,4hBAUA,+FAGA,oDACA,0EAC8C,uBAAGD,KAAK,kFAAkFC,OAAO,UAAjG,iDAD9C,uBAE6D,uBAAGD,KAAK,6EAA6EC,OAAO,UAA5F,iBAF7D,KAMA,6BAAK,gsBAgBL,mFAEE,8CAFF,mEAGgC,yCAHhC,2EAMA,yVAOA,wFAEE,8CAFF,wQAQA,kEACA,qYAQA,yBAAKF,UAAU,uCACb,kBAAC,IAAD,CACEF,MAAOT,EAAKc,cAAcN,gBAAgBC,MAC1CE,UAAU,cAGd,wOAMA,uLAGqB,yCAHrB,uBAIE,sCAJF,wEAOA,uCACW,uBAAGC,KAAK,kFAAkFC,OAAO,UAAjG,iBADX,KAIA,6BAAK,0SAOL,+CACmB,2CADnB,6RAMK,2CANL,IAM4B,uBAAGD,KAAK,uFAAuFC,OAAO,UAAtG,aAN5B,KASA,6BAAK,sXAaL,sfAUA,yBAAKF,UAAU,uCACb,kBAAC,IAAD,CACEF,MAAOT,EAAKe,eAAeP,gBAAgBC,MAC3CE,UAAU,cAGd,sWAOA,+CACA,2CACe,uBAAGC,KAAK,6DAA6DC,OAAO,UAA5E,qBADf,kNAK+B,yCAL/B,qCAMoB,wCANpB,uHAUA,2BACE,uBAAGD,KAAK,gFAAgFC,OAAO,UAA/F,0BADF,oFAMA,6BAAK,ilBAmBL,0LAGsB,6CAHtB,gLASA,6BAAK,giCA+BL,0FAEE,6CAFF,2EAGgC,6DAHhC,MAIE,uDAJF,+HAMmC,iDANnC,2FAUA,qPAMA,kDACA,mEACuC,uBAAGD,KAAK,2CAA2CC,OAAO,UAA1D,gBADvC,+RAOE,uBAAGD,KAAK,+CAA+CC,OAAO,UAA9D,eAPF,OAQE,uBAAGD,KAAK,4CAA4CC,OAAO,UAA3D,YARF,2EASqE,uBAAGD,KAAK,gFAAgFC,OAAO,UAA/F,eATrE,KAYA,6BAAK,iMAKL,ycASA,6QAIgD,uBAAGD,KAAK,+DAA+DC,OAAO,UAA9E,+BAJhD,wBAmDK,mBAAAG,GAAK,OAClB,kBAAC,cAAD,CACEC,MAvCY,aAwCZC,OAAQ,SAAAlB,GAAI,OACV,kBAACF,EAAD,eAAuBC,SAAUiB,EAAMjB,SAAUC,KAAMA,GAAUgB,KAHrE","file":"component---src-pages-engineers-better-wdc-performance-with-promises-js-e7f930d9763456198237.js","sourcesContent":["/**\n * This page represents \"legacy\" content that doesn't quite fit the blog mould,\n * but gets consistent-ish enough traffic that it deserves to live on, off-nav.\n */\n\nimport React from \"react\"\nimport { graphql, StaticQuery } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nimport Layout from \"../../components/layout\"\nimport SEO from \"../../components/seo\"\n\nimport \"../../utils/normalize.css\"\nimport \"../../utils/css/screen.css\"\n\nconst LegacyWdcPromisesPage = ({ data }, location) => {\n  const siteTitle = data.site.siteMetadata.title\n\n  return (\n    <Layout title={siteTitle}>\n      <SEO\n        title=\"Better WDC Performance with Promises\"\n        keywords={[`Tableau`, `Web Data Connector`, `JavaScript`, `Performance`, `Promise`]}\n        img={`${data.promises.childImageSharp.fluid.src}`}\n      />\n\n      <article className=\"post-content page-template no-image\">\n        <header className=\"post-content-header\">\n          <h1 className=\"post-content-title\">Better WDC Performance with Promises</h1>\n        </header>\n        <div className=\"post-content-body\">\n          <figure className=\"kg-card kg-image-card kg-width-full\">\n            <Img\n              fluid={data.promises.childImageSharp.fluid}\n              className=\"kg-image\"\n            />\n            <figcaption>image courtesy <a href=\"https://www.flickr.com/photos/elsabordelossegundos/15418211523/\" target=\"_blank\">mariadelajuana</a></figcaption>\n          </figure>\n          <p>\n            Web Data Connectors give analysts access to worlds of data\n            previously locked away behind APIs. The WDC SDK provides\n            developers a platform to standardize data extraction in a way\n            that's friendly to Tableau's suite of analytics and business\n            intelligence software.\n          </p>\n          <p>\n            Unlike traditional databases and other data stores that are often\n            able to return a complete set of data with a single query, most\n            APIs only expose small chunks of data that must be requested\n            separately and stitched together. Typically, this is done using\n            some form of pagination: a client asks the API for some number of\n            records, then the API responds with these records, as well as some\n            metadata about how many more records remain. Based on this\n            metadata, the client may choose to perform additional queries.\n          </p>\n          <p>\n            This process constitutes the majority of a WDC's responsibility.\n          </p>\n          <h3>The standard WDC way</h3>\n          <p>\n            To this end, the WDC SDK provides a helpful <a href=\"http://onlinehelp.tableau.com/current/api/wdc/en-us/help.htm#WDC/wdc_paging.htm\" target=\"_blank\">interface\n            for managing the pagination process</a>. Take for example, <a href=\"https://gist.github.com/iamEAP/6a4212c17b22004117f2#file-wdc-no-promise-js\" target=\"_blank\">the\n            following</a>:\n          </p>\n\n          <pre><code>{(`myConnector.getTableData = function(lastRecordToken) {\n  // If Tableau gave a page, use it. But default to 1.\n  var pageNumber = lastRecordToken ? lastRecordToken + 1 : 1;\n\n  // Load this page of data from the API.\n  $.getJSON('https://api.example.com?page=' + pageNumber, function (response) {\n    // Check if the current page is not the last page.\n    var hasMoreData = pageNumber < response.metadata.lastPage;\n\n    // Pass data and current page back to Tableau. If\n    // hasMoreData evaluated to TRUE, Tableau will call\n    // getTableData again using this pageNumber value.\n    tableau.dataCallback(response.records, pageNumber, hasMoreData);\n  });\n}`)}</code></pre>\n\n          <p>\n            In the contrived example above, we've implemented the\n            <code>getTableData</code> method that Tableau calls on our\n            connector. It uses the jQuery <code>getJSON</code> method to pull\n            data from an API, defaulting to the first page of data.\n          </p>\n          <p>\n            When the API returns a response, we pass the records to Tableau,\n            along with some state (the page number we just loaded), and a\n            boolean value indicating whether or not additional data should be\n            returned (which we determine based on the current page and a\n            hypothetical \"lastPage\" metadata value returned by the API).\n          </p>\n          <p>\n            If more data should be returned, Tableau knows to call the\n            <code>getTableData</code> method again, this time passing in the\n            page number / state value we provided, which the code above will\n            use to pull in the next page of data.  This process repeats itself\n            until we've run through all available pages and Tableau returns\n            control to the end-user.\n          </p>\n          <h3>The problem with the standard flow</h3>\n          <p>\n            We're able to accomplish a lot with a small amount of code, but\n            this isn't the most efficient way to pull down all of our data. A\n            significant amount of time is wasted on every page, waiting for the\n            API to receive the request, process it, and return a response.  A\n            waterfall chart representing resource usage for the above code\n            might look something like this:\n          </p>\n          <div className=\"kg-card kg-image-card kg-width-full\">\n            <Img\n              fluid={data.waterfallSync.childImageSharp.fluid}\n              className=\"kg-image\"\n            />\n          </div>\n          <p>\n            As you can imagine, the performance penalty grows considerably as\n            data sets grow larger or if APIs enforce low limits on number of\n            records retrieved per query relative to the number of records\n            desired.\n          </p>\n          <p>\n            Although JavaScript execution is single-threaded (meaning only one\n            piece of code can be executed at any given time), the asynchronous\n            nature of jQuery's <code>getJSON</code> (and its underlying\n            <code>ajax</code> method) can be exploited to effectively pull down\n            data in parallel.\n          </p>\n          <p>\n            Consider <a href=\"https://gist.github.com/iamEAP/6a4212c17b22004117f2#file-thread-of-execution-js\" target=\"_blank\">the following</a>:\n          </p>\n\n          <pre><code>{(`$.getJSON('https://api.example.com', function (response) {\n  // Executed later, once api.example.com responds with data.\n  console.log('Second: Just got data!');\n});\n\n// Executed immediately, even before the API responds.\nconsole.log('First: No data yet!');`)}</code></pre>\n          <p>\n            Although we call <code>$.getJSON</code> with the intention of doing\n            something with its response data in a callback, the thread of\n            execution first continues to the instructions immediately following\n            the call. This becomes useful for us when we realize the same\n            principal holds true if we were to make a series of calls\n            to <code>$.getJSON</code> <a href=\"https://gist.github.com/iamEAP/6a4212c17b22004117f2#file-thread-of-execution-loop-js\" target=\"_blank\">in a loop</a>:\n          </p>\n\n          <pre><code>{(`var pageNumbers = [1, 2, 3],\n    allResults = [];\n\n// Loop through all pages.\npageNumbers.forEach(function (page) {\n  $.getJSON('https://api.example.com?page=' + page, function (response) {\n    console.log('Later: Got data for page ' + page);\n    allResults.push(response.records);\n  });\n});\n\nconsole.log('First: No data yet!');`)}</code></pre>\n\n          <p>\n            All three API calls are initiated in rapid succession in a\n            non-blocking way, immediately after which \"First: No data yet!\" is\n            printed to the console. When each request is eventually fulfilled,\n            additional messages are logged. Note that rather than sending data\n            to Tableau with each response, we append the data to an array store\n            with the intention of passing the complete data set back to Tableau\n            later. A waterfall chart for the code above might look something\n            like this:\n          </p>\n          <div className=\"kg-card kg-image-card kg-width-full\">\n            <Img\n              fluid={data.waterfallAsync.childImageSharp.fluid}\n              className=\"kg-image\"\n            />\n          </div>\n          <p>\n            We dramatically improve performance (by just under 3x), but we also\n            create complications for ourselves. In the above example, how do we\n            know when all API calls have been fulfilled? If the thread of\n            execution immediately returns to us after the loop, how do we wait\n            to pass control back to Tableau with the complete set of data?\n          </p>\n          <h3>Enter: Promises</h3>\n          <p>\n            Promises are <a href=\"https://en.wikipedia.org/wiki/Futures_and_promises#History\" target=\"_blank\">not\n            a new concept</a>. Devised as a way to simplify synchronicity in\n            concurrent or asynchronous programming languages, the idea is\n            straightforward: a Promise is a placeholder for a value that hasn't\n            yet been computed. It can be <em>fulfilled</em> when the value\n            becomes known, or <em>rejected</em> in case of error. You can\n            \"then\" specify code that gets executed when the Promise moves from\n            pending to fulfilled.\n          </p>\n          <p>\n            <a href=\"https://gist.github.com/iamEAP/6a4212c17b22004117f2#file-wdc-naive-promise-js\" target=\"_blank\">Here's\n            a naive example</a> to illustrate how you might use Promises in\n            JavaScript in a Web Data Connector:\n          </p>\n\n          <pre><code>{(`// Return a Promise for the given URL.\nvar returnApiDataFor = function(url) {\n  return new Promise(function(fulfill, reject) {\n    // When the promise is invoked, send the request.\n    $.getJSON(url, function (response) {\n      // Fulfill the promise with data returned.\n      fulfill(response.records);\n    });\n  });\n};\n\n// Invoke the promise for a given URL.\nreturnApiDataFor('https://api.example.com')\n  // Once the promise is fulfilled...\n  .then(function (records) {\n    // Pass data to Tableau.\n    tableau.dataCallback(records);\n  });`)}</code></pre>\n\n          <p>\n            If we want to wait for a series of API calls to be fulfilled before\n            taking action, we can use a feature in the JavaScript specification\n            for Promises called <code>Promise.all</code>. With it, we can\n            specify an iterable object (like an array) of Promises, wait for\n            them all to be fulfilled, and then react based on the aggregation\n            of all returned values.\n          </p>\n\n          <pre><code>{(`// Use the same Promise return helper from above.\nvar returnApiDataFor = function(url) {\n  return new Promise(function(fulfill, reject) {\n    $.getJSON(url, function (response) {\n      fulfill(response.records);\n    });\n  });\n};\n\n// Define a helper to map a URL and page list to Promises.\nvar allPromisesFor = function(baseUrl, pages) {\n  // Map each page to a URL wrapped in a Promise to retrieve its data.\n  return pages.map(function(pageNumber) {\n    return returnApiDataFor(baseUrl + '?page=' + pageNumber);\n  });\n};\n\n// Invoke all Promises for a given base URL and pages.\nPromise.all(allPromisesFor('https://api.example.com', [1, 2, 3])\n  // Once all promises are fulfilled...\n  .then(function (recordSet) {\n    var allRecords = [];\n\n    // Concatenate / union all page responses to a single array.\n    recordSet.forEach(function(records) {\n      allRecords = allRecords.concat(records);\n    });\n\n    // Pass the complete data set to Tableau.\n    tableau.dataCallback(allRecords);\n  });`)}</code></pre>\n          <p>\n            The API is simple. Just as a Promise maps to a future value,\n            <code>Promise.all</code> takes an array of Promises and maps them\n            to an array of future values: <code>[Promise, Promise, Promise]</code> =>\n            <code>[[{}], [{}], [{}]]</code>. After a simple union-like\n            operation during post-processing, we can pass the data back to\n            Tableau in the format it expects <code>[{}, {}, {}]</code>, with\n            no need to instruct Tableau to loop back and ask our WDC for\n            additional records.\n          </p>\n          <p>\n            Promises provide a way to strike a balance between application\n            performance and complexity: we can take advantage of some of\n            JavaScript's asynchronous features while maintaining code\n            readability and maintainability.\n          </p>\n          <h3>Things to consider</h3>\n          <p>\n            The Promise specification is part of <a href=\"https://github.com/lukehoban/es6features\" target=\"_blank\">ECMAScript\n            6</a>, the first significant update to the JavaScript language\n            since 2009.  Although many modern browsers support Promises\n            natively, they are currently unavailable in the WDC connection\n            window in Tableau.  In order to use them, you will have to include\n            a shim or polyfill before your code.\n            <a href=\"https://github.com/jakearchibald/es6-promise\" target=\"_blank\">ES6-Promise</a> and\n            <a href=\"https://github.com/petkaantonov/bluebird/\" target=\"_blank\">bluebird</a> are\n            good options, but anything that is faithful to the spec should do. <a href=\"https://gist.github.com/iamEAP/6a4212c17b22004117f2#file-install-promise-html\" target=\"_blank\">For example</a>:\n          </p>\n\n          <pre><code>{(`<script src=\"es6-promise.min.js\"></script>\n<script src=\"jquery.min.js\"></script>\n<script src=\"wdc-sdk.js\"></script>\n<script src=\"your_wdc.js\"></script>`)}</code></pre>\n\n          <p>\n            It's also worth noting that the number of persistent connections\n            that can be open for a given domain at any given time is fixed.\n            Browsers set this number anywhere between 4 and 8, but the WDC\n            seems to allow up to 6 simultaneous connections to a single host.\n            This ensures you can't overwhelm an API provider by opening up\n            hundreds or thousands of connections simultaneously. No need to\n            implement that safety mechanism yourself.\n          </p>\n          <p>\n            Finally, for the sake of brevity and clarity, all of the examples\n            above omit error handling of any kind.  Beyond the benefits\n            outlined above, Promises can also help simplify fault tolerance in\n            asynchronous applications. I encourage you to <a href=\"https://blog.domenic.me/youre-missing-the-point-of-promises/\" target=\"_blank\">explore\n            JavaScript Promises</a> in more depth.\n          </p>\n\n        </div>\n      </article>\n    </Layout>\n  )\n}\n\nconst indexQuery = graphql`\n  query {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n    promises: file(\n      relativePath: { eq: \"legacy/promises.jpg\" }\n    ) {\n      childImageSharp {\n        fluid(maxWidth: 1360) {\n          ...GatsbyImageSharpFluid\n        }\n      }\n    }\n    waterfallSync: file(\n      relativePath: { eq: \"legacy/waterfall-sync.png\" }\n    ) {\n      childImageSharp {\n        fluid(maxWidth: 1360) {\n          ...GatsbyImageSharpFluid\n        }\n      }\n    }\n    waterfallAsync: file(\n      relativePath: { eq: \"legacy/waterfall-async.png\" }\n    ) {\n      childImageSharp {\n        fluid(maxWidth: 1360) {\n          ...GatsbyImageSharpFluid\n        }\n      }\n    }\n  }\n`\n\nexport default props => (\n  <StaticQuery\n    query={indexQuery}\n    render={data => (\n      <LegacyWdcPromisesPage location={props.location} data={data} {...props} />\n    )}\n  />\n)\n"],"sourceRoot":""}